/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * Written (W) 2011 Heiko Strathmann
 * Copyright (C) 2011 Berlin Institute of Technology and Max-Planck-Society
 */

#ifndef __PARAMETERCOMBINATION_H_
#define __PARAMETERCOMBINATION_H_

#include "base/SGObject.h"
#include "base/DynArray.h"

namespace shogun
{

class CModelSelectionParameters;

/**
 * @brief class that holds ONE combination of parameters for a learning machine.
 * The structure is organized as a tree. Every node may hold a name or an
 * instance of a Parameter class. Nodes may have children. The nodes are
 * organized in such way, that every parameter of a model for model selection
 * has one node and sub-parameters are stored in sub-nodes. Using a tree of this
 * class, parameters of models may easily be set.
 * There are these types of nodes:
 * -root node: no name and no Parameter instance, every tree has such a node as
 * root. Has childs.
 * -name node: a node with only a name. This is used to bundle parameters that
 * are directly of from the learning machine, like "kernel". Has childs.
 * -Parameter node: a node with no name and an instance of Parameter, filled
 * with one or more values. There may be different elements in these Parameter
 * instances. Parameter nodes may have children with sub-parameters.
 *
 * Again: Leafs of the tree may only be Parameter nodes.
 *
 */
class CParameterCombination: public CSGObject
{
	friend class CModelSelectionParameters;

public:
	/** constructor for a root node */
	CParameterCombination();

	/** Prints a representation of the current node
	 *
	 * @param prefix number of '\t' signs that will be prefixed for every output.
	 * At each recursion level, one is added.
	 */
	void print(int prefix_num=0);

	/** constructor for a name node */
	CParameterCombination(char* name);

	/** constructor for a Parameter node */
	CParameterCombination(Parameter* param);

	/** destructor */
	~CParameterCombination();

	/** appends a child to this node
	 *
	 * @param child child to append
	 */
	void append_child(CParameterCombination* child);

	/** Copies the complete tree of this node. Note that nodes are actually
	 * copied. If this is a parameter node, a NEW Parameter instance to the same
	 * data is created in the copy
	 *
	 * @return copy of the tree with this node as root as described above
	 */
	CParameterCombination* copy_tree();

	/** Destroys the current node. Possibly also data and recursively for all
	 * child nodes. Do NOT destroy data if nodes contain Parameter instances
	 * from stack. All nodes that were generated by copy_tree() may be destroyed
	 *
	 * @param recursive if true, all children are recursively destroyed
	 * @param destroy_data if true, all data destroyed
	 */
	void destroy(bool recursive, bool destroy_data);

	/** Fills a DynArray<Parameter*> with pointers to newly created Parameter
	 * instances, which contain all combinations of the provided Parameters. Old
	 * Parameter instances are deleted, so the input gets destroyed.
	 *
	 * @param set_1 DynArray of Parameter instances
	 * @param set_2 DynArray of Parameter instances
	 * @param result an DynArray where the combinations are appended to
	 */
	static void parameter_set_multiplication(DynArray<Parameter*>& set_1,
			DynArray<Parameter*>& set_2, DynArray<Parameter*>& result);

	/** Takes a set of sets of leafs nodes (!) and produces a set of instances
	 * of this class that contain every combination of the paramters in the leaf
	 * nodes in their Parameter variables. All combinations are put into a newly
	 * created tree. The root of this tree wil be a copy of a specified node
	 *
	 * Provided root node, input sets, as well as the Parameter instances are
	 * deleted. Newly created Parameter instances are added to the result set.
	 *
	 * @param sets Set of sets of leafs to combine
	 * @param new_root root node that is copied and put as root into all result
	 * trees
	 * @param result result set of tree combinations
	 */
	static void leaf_sets_multiplication(
			DynArray<DynArray<CParameterCombination*>*>& sets,
			CParameterCombination* new_root,
			DynArray<CParameterCombination*>& result);

	/** Returns the name of the SGSerializable instance.  It MUST BE
	 *  the CLASS NAME without the prefixed `C'.
	 *
	 * @return name of the SGSerializable
	 */
	inline virtual const char* get_name() const
	{
		return "CParameterCombination";
	}

	/** checks whether this node has children
	 *
	 * @return true if node has children
	 */
	bool has_children() { return m_child_nodes->get_num_elements()>0; }

private:
	char* m_node_name;
	Parameter* m_param;
	DynArray<CParameterCombination*>* m_child_nodes;
};
}

#endif /* __PARAMETERCOMBINATION_H_ */
